:mod:`ape.types`
================

.. py:module:: ape.types



.. raw:: html

   <h3>Submodules</h3>

.. toctree::
   :titlesonly:
   :maxdepth: 1

   abstract/index.rst
   contract/index.rst
   manifest/index.rst




.. raw:: html

   <h3>Package Contents</h3>

**Classes**:

.. autoapisummary::

   ape.types.ABI
   ape.types.Bytecode
   ape.types.Checksum
   ape.types.Compiler
   ape.types.ContractType
   ape.types.Source
   ape.types.PackageManifest
   ape.types.PackageMeta





-----------


.. py:class:: ABI

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: name
      :annotation: :str = 

      

   .. attribute:: inputs
      :annotation: :List[ABIType] = []

      

   .. attribute:: outputs
      :annotation: :List[ABIType] = []

      

   .. attribute:: stateMutability
      :annotation: :Optional[str]

      

   .. attribute:: anonymous
      :annotation: :Optional[bool]

      

   .. attribute:: type
      :annotation: :str

      

   .. py:method:: signature(self) -> str
      :property:

      String representing the function/event signature, which includes the arg names and types,
      and output names (if any) and type(s)


   .. py:method:: selector(self) -> str
      :property:

      String representing the function selector, used to compute ``method_id`` and ``event_id``.


   .. py:method:: is_event(self) -> bool
      :property:


   .. py:method:: is_payable(self) -> bool
      :property:


   .. py:method:: is_stateful(self) -> bool
      :property:


   .. py:method:: from_dict(cls, params: Dict)
      :classmethod:





.. py:class:: Bytecode

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: bytecode
      :annotation: :Optional[str]

      

   .. attribute:: linkReferences
      :annotation: :Optional[List[LinkReference]]

      

   .. attribute:: linkDependencies
      :annotation: :Optional[List[LinkDependency]]

      

   .. py:method:: __repr__(self) -> str

      Return repr(self).


   .. py:method:: from_dict(cls, params: Dict)
      :classmethod:





.. py:class:: Checksum

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: algorithm
      :annotation: :str

      

   .. attribute:: hash
      :annotation: :str

      




.. py:class:: Compiler

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: version
      :annotation: :str

      

   .. attribute:: settings
      :annotation: :Optional[str]

      

   .. attribute:: contractTypes
      :annotation: :Optional[List[str]]

      




.. py:class:: ContractType

   Bases: :py:obj:`ape.types.abstract.FileMixin`, :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: _keep_fields_
      :annotation: :Set[str]

      

   .. attribute:: _skip_fields_
      :annotation: :Set[str]

      

   .. attribute:: contractName
      :annotation: :str

      

   .. attribute:: sourceId
      :annotation: :Optional[str]

      

   .. attribute:: deploymentBytecode
      :annotation: :Optional[Bytecode]

      

   .. attribute:: runtimeBytecode
      :annotation: :Optional[Bytecode]

      

   .. attribute:: abi
      :annotation: :List[ABI] = []

      

   .. attribute:: userdoc
      :annotation: :Optional[str]

      

   .. attribute:: devdoc
      :annotation: :Optional[str]

      

   .. py:method:: constructor(self) -> Optional[ABI]
      :property:


   .. py:method:: fallback(self) -> Optional[ABI]
      :property:


   .. py:method:: events(self) -> List[ABI]
      :property:


   .. py:method:: calls(self) -> List[ABI]
      :property:


   .. py:method:: transactions(self) -> List[ABI]
      :property:


   .. py:method:: from_dict(cls, params: Dict)
      :classmethod:





.. py:class:: Source

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: checksum
      :annotation: :Optional[Checksum]

      

   .. attribute:: urls
      :annotation: :List[str] = []

      

   .. attribute:: content
      :annotation: :Optional[str]

      

   .. attribute:: installPath
      :annotation: :Optional[str]

      

   .. attribute:: type
      :annotation: :Optional[str]

      

   .. attribute:: license
      :annotation: :Optional[str]

      

   .. py:method:: load_content(self)

      Loads resource at ``urls`` into ``content``.


   .. py:method:: compute_checksum(self, algorithm: str = 'md5', force: bool = False)

      Compute the checksum if ``content`` exists but ``checksum`` doesn't
      exist yet. Or compute the checksum regardless if ``force`` is ``True``.


   .. py:method:: from_dict(cls, params: Dict)
      :classmethod:





.. py:class:: PackageManifest

   Bases: :py:obj:`ape.types.abstract.FileMixin`, :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: manifest
      :annotation: :str = ethpm/3

      

   .. attribute:: name
      :annotation: :Optional[str]

      

   .. attribute:: version
      :annotation: :Optional[str]

      

   .. attribute:: meta
      :annotation: :Optional[PackageMeta]

      

   .. attribute:: sources
      :annotation: :Optional[Dict[str, ape.types.contract.Source]]

      

   .. attribute:: contractTypes
      :annotation: :Optional[Dict[str, ape.types.contract.ContractType]]

      

   .. attribute:: compilers
      :annotation: :Optional[List[ape.types.contract.Compiler]]

      

   .. attribute:: deployments
      :annotation: :Optional[Dict[str, Dict[str, ape.types.contract.ContractInstance]]]

      

   .. attribute:: buildDependencies
      :annotation: :Optional[Dict[str, str]]

      

   .. py:method:: __getattr__(self, attr_name: str)


   .. py:method:: from_dict(cls, params: Dict)
      :classmethod:





.. py:class:: PackageMeta

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: authors
      :annotation: :Optional[List[str]]

      

   .. attribute:: license
      :annotation: :Optional[str]

      

   .. attribute:: description
      :annotation: :Optional[str]

      

   .. attribute:: keywords
      :annotation: :Optional[List[str]]

      

   .. attribute:: links
      :annotation: :Optional[Dict[str, str]]

      



