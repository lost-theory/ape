:mod:`ape.types.contract`
=========================

.. py:module:: ape.types.contract




.. raw:: html

   <h3>Module Contents</h3>

**Classes**:

.. autoapisummary::

   ape.types.contract.LinkDependency
   ape.types.contract.LinkReference
   ape.types.contract.Bytecode
   ape.types.contract.ContractInstance
   ape.types.contract.Compiler
   ape.types.contract.ABIType
   ape.types.contract.ABI
   ape.types.contract.ContractType
   ape.types.contract.Checksum
   ape.types.contract.Source





-----------


.. py:class:: LinkDependency

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: offsets
      :annotation: :List[int]

      

   .. attribute:: type
      :annotation: :str

      

   .. attribute:: value
      :annotation: :str

      




.. py:class:: LinkReference

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: offsets
      :annotation: :List[int]

      

   .. attribute:: length
      :annotation: :int

      

   .. attribute:: name
      :annotation: :Optional[str]

      




.. py:class:: Bytecode

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: bytecode
      :annotation: :Optional[str]

      

   .. attribute:: linkReferences
      :annotation: :Optional[List[LinkReference]]

      

   .. attribute:: linkDependencies
      :annotation: :Optional[List[LinkDependency]]

      

   .. py:method:: __repr__(self) -> str

      Return repr(self).


   .. py:method:: from_dict(cls, params: Dict)
      :classmethod:





.. py:class:: ContractInstance

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: contractType
      :annotation: :str

      

   .. attribute:: address
      :annotation: :str

      

   .. attribute:: transaction
      :annotation: :Optional[str]

      

   .. attribute:: block
      :annotation: :Optional[str]

      

   .. attribute:: runtimeBytecode
      :annotation: :Optional[Bytecode]

      

   .. py:method:: from_dict(cls, params: Dict)
      :classmethod:





.. py:class:: Compiler

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: version
      :annotation: :str

      

   .. attribute:: settings
      :annotation: :Optional[str]

      

   .. attribute:: contractTypes
      :annotation: :Optional[List[str]]

      




.. py:class:: ABIType

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: name
      :annotation: :str = 

      

   .. attribute:: indexed
      :annotation: :Optional[bool]

      

   .. attribute:: type
      :annotation: :Union[str, ABIType]

      

   .. attribute:: internalType
      :annotation: :Optional[str]

      

   .. py:method:: canonical_type(self) -> str
      :property:





.. py:class:: ABI

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: name
      :annotation: :str = 

      

   .. attribute:: inputs
      :annotation: :List[ABIType] = []

      

   .. attribute:: outputs
      :annotation: :List[ABIType] = []

      

   .. attribute:: stateMutability
      :annotation: :Optional[str]

      

   .. attribute:: anonymous
      :annotation: :Optional[bool]

      

   .. attribute:: type
      :annotation: :str

      

   .. py:method:: signature(self) -> str
      :property:

      String representing the function/event signature, which includes the arg names and types,
      and output names (if any) and type(s)


   .. py:method:: selector(self) -> str
      :property:

      String representing the function selector, used to compute ``method_id`` and ``event_id``.


   .. py:method:: is_event(self) -> bool
      :property:


   .. py:method:: is_payable(self) -> bool
      :property:


   .. py:method:: is_stateful(self) -> bool
      :property:


   .. py:method:: from_dict(cls, params: Dict)
      :classmethod:





.. py:class:: ContractType

   Bases: :py:obj:`ape.types.abstract.FileMixin`, :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: _keep_fields_
      :annotation: :Set[str]

      

   .. attribute:: _skip_fields_
      :annotation: :Set[str]

      

   .. attribute:: contractName
      :annotation: :str

      

   .. attribute:: sourceId
      :annotation: :Optional[str]

      

   .. attribute:: deploymentBytecode
      :annotation: :Optional[Bytecode]

      

   .. attribute:: runtimeBytecode
      :annotation: :Optional[Bytecode]

      

   .. attribute:: abi
      :annotation: :List[ABI] = []

      

   .. attribute:: userdoc
      :annotation: :Optional[str]

      

   .. attribute:: devdoc
      :annotation: :Optional[str]

      

   .. py:method:: constructor(self) -> Optional[ABI]
      :property:


   .. py:method:: fallback(self) -> Optional[ABI]
      :property:


   .. py:method:: events(self) -> List[ABI]
      :property:


   .. py:method:: calls(self) -> List[ABI]
      :property:


   .. py:method:: transactions(self) -> List[ABI]
      :property:


   .. py:method:: from_dict(cls, params: Dict)
      :classmethod:





.. py:class:: Checksum

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: algorithm
      :annotation: :str

      

   .. attribute:: hash
      :annotation: :str

      




.. py:class:: Source

   Bases: :py:obj:`ape.types.abstract.SerializableType`

   .. attribute:: checksum
      :annotation: :Optional[Checksum]

      

   .. attribute:: urls
      :annotation: :List[str] = []

      

   .. attribute:: content
      :annotation: :Optional[str]

      

   .. attribute:: installPath
      :annotation: :Optional[str]

      

   .. attribute:: type
      :annotation: :Optional[str]

      

   .. attribute:: license
      :annotation: :Optional[str]

      

   .. py:method:: load_content(self)

      Loads resource at ``urls`` into ``content``.


   .. py:method:: compute_checksum(self, algorithm: str = 'md5', force: bool = False)

      Compute the checksum if ``content`` exists but ``checksum`` doesn't
      exist yet. Or compute the checksum regardless if ``force`` is ``True``.


   .. py:method:: from_dict(cls, params: Dict)
      :classmethod:




