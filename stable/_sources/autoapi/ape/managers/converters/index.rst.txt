:mod:`ape.managers.converters`
==============================

.. py:module:: ape.managers.converters




.. raw:: html

   <h3>Module Contents</h3>

**Classes**:

.. autoapisummary::

   ape.managers.converters.HexConverter
   ape.managers.converters.AddressAPIConverter
   ape.managers.converters.HexAddressConverter
   ape.managers.converters.ConversionManager




**Attributes**:

.. autoapisummary::

   ape.managers.converters.hex_converter
   ape.managers.converters.address_api_converter
   ape.managers.converters.hex_address_converter



-----------


.. py:class:: HexConverter

   Bases: :py:obj:`ape.api.ConverterAPI`

   Abstract base class for generic types.

   A generic type is typically declared by inheriting from
   this class parameterized with one or more type variables.
   For example, a generic mapping type might be defined as::

     class Mapping(Generic[KT, VT]):
         def __getitem__(self, key: KT) -> VT:
             ...
         # Etc.

   This class can then be used as follows::

     def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
         try:
             return mapping[key]
         except KeyError:
             return default

   .. py:method:: is_convertible(self, value: str) -> bool

      Returns `True` if string value provided by `value` is convertible using
      `self.convert(value)`


   .. py:method:: convert(self, value: str) -> bytes

      Implements any conversion logic on `value` to produce `ABIType`.

      Must throw if not convertible.





.. data:: hex_converter
   

   



.. py:class:: AddressAPIConverter

   Bases: :py:obj:`ape.api.ConverterAPI`

   Abstract base class for generic types.

   A generic type is typically declared by inheriting from
   this class parameterized with one or more type variables.
   For example, a generic mapping type might be defined as::

     class Mapping(Generic[KT, VT]):
         def __getitem__(self, key: KT) -> VT:
             ...
         # Etc.

   This class can then be used as follows::

     def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
         try:
             return mapping[key]
         except KeyError:
             return default

   .. py:method:: is_convertible(self, value: Any) -> bool

      Returns `True` if string value provided by `value` is convertible using
      `self.convert(value)`


   .. py:method:: convert(self, value: ape.api.AddressAPI) -> ape.types.AddressType

      Implements any conversion logic on `value` to produce `ABIType`.

      Must throw if not convertible.





.. data:: address_api_converter
   

   



.. py:class:: HexAddressConverter

   Bases: :py:obj:`ape.api.ConverterAPI`

   Abstract base class for generic types.

   A generic type is typically declared by inheriting from
   this class parameterized with one or more type variables.
   For example, a generic mapping type might be defined as::

     class Mapping(Generic[KT, VT]):
         def __getitem__(self, key: KT) -> VT:
             ...
         # Etc.

   This class can then be used as follows::

     def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
         try:
             return mapping[key]
         except KeyError:
             return default

   .. py:method:: is_convertible(self, value: str) -> bool

      Returns `True` if string value provided by `value` is convertible using
      `self.convert(value)`


   .. py:method:: convert(self, value: str) -> ape.types.AddressType

      Implements any conversion logic on `value` to produce `ABIType`.

      Must throw if not convertible.





.. data:: hex_address_converter
   

   



.. py:class:: ConversionManager

   .. attribute:: config
      :annotation: :ape.managers.config.ConfigManager

      

   .. attribute:: plugin_manager
      :annotation: :ape.plugins.PluginManager

      

   .. attribute:: networks
      :annotation: :ape.managers.networks.NetworkManager

      

   .. py:method:: _converters(self) -> Dict[Type, List[ape.api.ConverterAPI]]


   .. py:method:: is_type(self, value: Any, type: Type) -> bool


   .. py:method:: convert(self, value: Any, type: Type) -> Any




