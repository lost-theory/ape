:mod:`ape.api`
==============

.. py:module:: ape.api



.. raw:: html

   <h3>Submodules</h3>

.. toctree::
   :titlesonly:
   :maxdepth: 1

   accounts/index.rst
   address/index.rst
   base/index.rst
   compiler/index.rst
   config/index.rst
   contracts/index.rst
   convert/index.rst
   explorers/index.rst
   networks/index.rst
   providers/index.rst




.. raw:: html

   <h3>Package Contents</h3>

**Classes**:

.. autoapisummary::

   ape.api.AccountAPI
   ape.api.AccountContainerAPI
   ape.api.Address
   ape.api.AddressAPI
   ape.api.ContractLog
   ape.api.ConverterAPI
   ape.api.ExplorerAPI
   ape.api.EcosystemAPI
   ape.api.NetworkAPI
   ape.api.ProviderContextManager
   ape.api.ProviderAPI
   ape.api.ReceiptAPI
   ape.api.TransactionAPI
   ape.api.TransactionStatusEnum



**Functions**:

.. autoapisummary::

   ape.api.create_network_type




-----------


.. py:class:: AccountAPI

   Bases: :py:obj:`ape.api.address.AddressAPI`

   .. attribute:: container
      :annotation: :AccountContainerAPI

      

   .. py:method:: __dir__(self) -> List[str]

      Default dir() implementation.


   .. py:method:: alias(self) -> Optional[str]
      :property:

      Override with whatever alias might want to use, if applicable


   .. py:method:: sign_message(self, msg: eth_account.messages.SignableMessage) -> Optional[eth_account.datastructures.SignedMessage]
      :abstractmethod:


   .. py:method:: sign_transaction(self, txn: ape.api.providers.TransactionAPI) -> Optional[eth_account.datastructures.SignedTransaction]
      :abstractmethod:


   .. py:method:: call(self, txn: ape.api.providers.TransactionAPI, send_everything: bool = False) -> ape.api.providers.ReceiptAPI


   .. py:method:: _convert(self) -> Callable


   .. py:method:: transfer(self, account: Union[str, ape.types.AddressType, ape.api.address.AddressAPI], value: Union[str, int, None] = None, data: Union[bytes, str, None] = None, **kwargs) -> ape.api.providers.ReceiptAPI


   .. py:method:: deploy(self, contract_type: ape.types.ContractType, *args, **kwargs) -> ape.api.contracts.ContractInstance





.. py:class:: AccountContainerAPI

   .. attribute:: data_folder
      :annotation: :pathlib.Path

      

   .. attribute:: account_type
      :annotation: :Type[AccountAPI]

      

   .. py:method:: aliases(self) -> Iterator[str]
      :property:


   .. py:method:: __len__(self) -> int
      :abstractmethod:


   .. py:method:: __iter__(self) -> Iterator[AccountAPI]
      :abstractmethod:


   .. py:method:: __getitem__(self, address: ape.types.AddressType) -> AccountAPI


   .. py:method:: append(self, account: AccountAPI)


   .. py:method:: __setitem__(self, address: ape.types.AddressType, account: AccountAPI)
      :abstractmethod:


   .. py:method:: remove(self, account: AccountAPI)


   .. py:method:: __delitem__(self, address: ape.types.AddressType)
      :abstractmethod:


   .. py:method:: __contains__(self, address: ape.types.AddressType) -> bool





.. py:class:: Address

   Bases: :py:obj:`AddressAPI`

   .. attribute:: _address
      :annotation: :ape.types.AddressType

      

   .. py:method:: address(self) -> ape.types.AddressType
      :property:





.. py:class:: AddressAPI

   .. attribute:: _provider
      :annotation: :Optional[ape.api.providers.ProviderAPI]

      

   .. py:method:: provider(self) -> ape.api.providers.ProviderAPI
      :property:


   .. py:method:: _receipt_class(self) -> Type[ape.api.providers.ReceiptAPI]
      :property:


   .. py:method:: _transaction_class(self) -> Type[ape.api.providers.TransactionAPI]
      :property:


   .. py:method:: address(self) -> ape.types.AddressType
      :property:


   .. py:method:: __dir__(self) -> List[str]

      Default dir() implementation.


   .. py:method:: __repr__(self) -> str

      Return repr(self).


   .. py:method:: __str__(self) -> str

      Return str(self).


   .. py:method:: nonce(self) -> int
      :property:


   .. py:method:: balance(self) -> int
      :property:


   .. py:method:: code(self) -> bytes
      :property:


   .. py:method:: codesize(self) -> int
      :property:


   .. py:method:: is_contract(self) -> bool
      :property:





.. py:class:: ContractLog

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: data
      :annotation: :Dict[str, Any]

      




.. py:class:: ConverterAPI

   Bases: :py:obj:`Generic`\ [\ :py:obj:`ConvertedType`\ ]

   Abstract base class for generic types.

   A generic type is typically declared by inheriting from
   this class parameterized with one or more type variables.
   For example, a generic mapping type might be defined as::

     class Mapping(Generic[KT, VT]):
         def __getitem__(self, key: KT) -> VT:
             ...
         # Etc.

   This class can then be used as follows::

     def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
         try:
             return mapping[key]
         except KeyError:
             return default

   .. attribute:: config
      :annotation: :ape.api.config.ConfigItem

      

   .. attribute:: networks
      :annotation: :ape.managers.networks.NetworkManager

      

   .. py:method:: is_convertible(self, value: Any) -> bool
      :abstractmethod:

      Returns `True` if string value provided by `value` is convertible using
      `self.convert(value)`


   .. py:method:: convert(self, value: Any) -> ConvertedType
      :abstractmethod:

      Implements any conversion logic on `value` to produce `ABIType`.

      Must throw if not convertible.





.. py:class:: ExplorerAPI

   An Explorer must work with a particular Network in a particular Ecosystem

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: network
      :annotation: :ape.api.networks.NetworkAPI

      

   .. attribute:: request_header
      :annotation: :str

      

   .. py:method:: get_address_url(self, address: str) -> str
      :abstractmethod:


   .. py:method:: get_transaction_url(self, transaction_hash: str) -> str
      :abstractmethod:





.. py:class:: EcosystemAPI

   An Ecosystem is a set of related Networks

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: network_manager
      :annotation: :ape.managers.networks.NetworkManager

      

   .. attribute:: config_manager
      :annotation: :ape.managers.config.ConfigManager

      

   .. attribute:: plugin_manager
      :annotation: :pluggy.PluginManager

      

   .. attribute:: data_folder
      :annotation: :pathlib.Path

      

   .. attribute:: request_header
      :annotation: :str

      

   .. attribute:: transaction_class
      :annotation: :Type[ape.api.providers.TransactionAPI]

      

   .. attribute:: receipt_class
      :annotation: :Type[ape.api.providers.ReceiptAPI]

      

   .. attribute:: _default_network
      :annotation: :str = development

      

   .. py:method:: config(self) -> ape.api.config.ConfigItem


   .. py:method:: networks(self) -> Dict[str, NetworkAPI]


   .. py:method:: __post_init__(self)


   .. py:method:: __iter__(self) -> Iterator[str]

      Provides the set of all valid Network names in the ecosystem


   .. py:method:: __getitem__(self, network_name: str) -> NetworkAPI


   .. py:method:: __getattr__(self, network_name: str) -> NetworkAPI


   .. py:method:: add_network(self, network_name: str, network: NetworkAPI)

      Used to attach new networks to an ecosystem (e.g. L2 networks like Optimism)


   .. py:method:: default_network(self) -> str
      :property:


   .. py:method:: set_default_network(self, network_name: str)


   .. py:method:: encode_deployment(self, deployment_bytecode: bytes, abi: Optional[ape.types.ABI], *args, **kwargs) -> ape.api.providers.TransactionAPI
      :abstractmethod:


   .. py:method:: encode_transaction(self, address: ape.types.AddressType, abi: ape.types.ABI, *args, **kwargs) -> ape.api.providers.TransactionAPI
      :abstractmethod:


   .. py:method:: decode_event(self, abi: ape.types.ABI, receipt: ape.api.providers.ReceiptAPI) -> ape.api.contracts.ContractLog
      :abstractmethod:





.. py:class:: NetworkAPI

   A Network is a wrapper around a Provider for a specific Ecosystem.

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: ecosystem
      :annotation: :EcosystemAPI

      

   .. attribute:: config_manager
      :annotation: :ape.managers.config.ConfigManager

      

   .. attribute:: plugin_manager
      :annotation: :pluggy.PluginManager

      

   .. attribute:: data_folder
      :annotation: :pathlib.Path

      

   .. attribute:: request_header
      :annotation: :str

      

   .. attribute:: _default_provider
      :annotation: :str = 

      

   .. py:method:: config(self) -> ape.api.config.ConfigItem


   .. py:method:: chain_id(self) -> int
      :property:


   .. py:method:: network_id(self) -> int
      :property:


   .. py:method:: explorer(self) -> Optional[ape.api.explorers.ExplorerAPI]


   .. py:method:: providers(self)


   .. py:method:: use_provider(self, provider_name: str, provider_settings: dict = None) -> ProviderContextManager


   .. py:method:: default_provider(self) -> str
      :property:


   .. py:method:: set_default_provider(self, provider_name: str)


   .. py:method:: use_default_provider(self) -> ProviderContextManager





.. py:class:: ProviderContextManager(network_manager: ape.managers.networks.NetworkManager, provider: ape.api.providers.ProviderAPI)

   .. attribute:: _connected_providers
      :annotation: :List[ape.api.providers.ProviderAPI] = []

      

   .. py:method:: __init__(self, network_manager: ape.managers.networks.NetworkManager, provider: ape.api.providers.ProviderAPI)


   .. py:method:: __enter__(self, *args, **kwargs)


   .. py:method:: __exit__(self, *args, **kwargs)





.. py:function:: create_network_type(chain_id: int, network_id: int) -> Type[NetworkAPI]

   Helper function that allows creating a :class:`NetworkAPI` subclass easily.




.. py:class:: ProviderAPI

   A Provider must work with a particular Network in a particular Ecosystem

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: network
      :annotation: :ape.api.networks.NetworkAPI

      

   .. attribute:: config
      :annotation: :ape.api.config.ConfigItem

      

   .. attribute:: provider_settings
      :annotation: :dict

      

   .. attribute:: data_folder
      :annotation: :pathlib.Path

      

   .. attribute:: request_header
      :annotation: :str

      

   .. py:method:: connect(self)
      :abstractmethod:


   .. py:method:: disconnect(self)
      :abstractmethod:


   .. py:method:: update_settings(self, new_settings: dict)
      :abstractmethod:


   .. py:method:: chain_id(self) -> int
      :property:


   .. py:method:: get_balance(self, address: str) -> int
      :abstractmethod:


   .. py:method:: get_code(self, address: str) -> bytes
      :abstractmethod:


   .. py:method:: get_nonce(self, address: str) -> int
      :abstractmethod:


   .. py:method:: estimate_gas_cost(self, txn: TransactionAPI) -> int
      :abstractmethod:


   .. py:method:: gas_price(self) -> int
      :property:


   .. py:method:: send_call(self, txn: TransactionAPI) -> bytes
      :abstractmethod:


   .. py:method:: get_transaction(self, txn_hash: str) -> ReceiptAPI
      :abstractmethod:


   .. py:method:: send_transaction(self, txn: TransactionAPI) -> ReceiptAPI
      :abstractmethod:


   .. py:method:: get_events(self, **filter_params) -> Iterator[dict]
      :abstractmethod:





.. py:class:: ReceiptAPI

   .. attribute:: txn_hash
      :annotation: :str

      

   .. attribute:: status
      :annotation: :TransactionStatusEnum

      

   .. attribute:: block_number
      :annotation: :int

      

   .. attribute:: gas_used
      :annotation: :int

      

   .. attribute:: gas_price
      :annotation: :int

      

   .. attribute:: logs
      :annotation: :List[dict] = []

      

   .. attribute:: contract_address
      :annotation: :Optional[str]

      

   .. py:method:: __post_init__(self)


   .. py:method:: __str__(self) -> str

      Return str(self).


   .. py:method:: decode(cls, data: dict) -> ReceiptAPI
      :classmethod:
      :abstractmethod:





.. py:class:: TransactionAPI

   .. attribute:: chain_id
      :annotation: :int = 0

      

   .. attribute:: sender
      :annotation: :str = 

      

   .. attribute:: receiver
      :annotation: :str = 

      

   .. attribute:: nonce
      :annotation: :Optional[int]

      

   .. attribute:: value
      :annotation: :int = 0

      

   .. attribute:: gas_limit
      :annotation: :Optional[int]

      

   .. attribute:: gas_price
      :annotation: :Optional[int]

      

   .. attribute:: data
      :annotation: :bytes = b''

      

   .. attribute:: signature
      :annotation: :Optional[eth_account.datastructures.SignedTransaction]

      

   .. py:method:: __post_init__(self)


   .. py:method:: is_valid(self)
      :property:


   .. py:method:: encode(self) -> bytes
      :abstractmethod:

      Take this object and produce a hash to sign to submit a transaction


   .. py:method:: as_dict(self) -> dict


   .. py:method:: __repr__(self) -> str

      Return repr(self).


   .. py:method:: __str__(self) -> str

      Return str(self).





.. py:class:: TransactionStatusEnum

   Bases: :py:obj:`enum.IntEnum`

   Enum where members are also (and must be) ints

   .. attribute:: failing
      :annotation: = 0

      

   .. attribute:: no_error
      :annotation: = 1

      



